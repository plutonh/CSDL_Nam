remark: gemm.cc:40:7: Loop 'col' is marked as complete unroll implied by the pipeline pragma
remark: gemm.cc:43:13: Loop 'product' is marked as complete unroll implied by the pipeline pragma
remark: gemm.cc:15:0: Unrolling loop 'col' (gemm.cc:40:7) in function 'mm' completely with a factor of 8
remark: gemm.cc:15:0: Unrolling loop 'product' (gemm.cc:43:13) in function 'mm' completely with a factor of 8
remark: gemm.cc:15:0: Unrolling loop 'product' (gemm.cc:43:13) in function 'mm' completely with a factor of 8
remark: gemm.cc:15:0: Unrolling loop 'product' (gemm.cc:43:13) in function 'mm' completely with a factor of 8
remark: gemm.cc:15:0: Unrolling loop 'product' (gemm.cc:43:13) in function 'mm' completely with a factor of 8
remark: gemm.cc:15:0: Unrolling loop 'product' (gemm.cc:43:13) in function 'mm' completely with a factor of 8
remark: gemm.cc:15:0: Unrolling loop 'product' (gemm.cc:43:13) in function 'mm' completely with a factor of 8
remark: gemm.cc:15:0: Unrolling loop 'product' (gemm.cc:43:13) in function 'mm' completely with a factor of 8
remark: gemm.cc:15:0: Unrolling loop 'product' (gemm.cc:43:13) in function 'mm' completely with a factor of 8
remark: gemm.cc:25:8: Applying array_partition to 'A_buff': Complete partitioning on dimension 2.
remark: gemm.cc:26:8: Applying array_partition to 'B_buff': Complete partitioning on dimension 1. Complete partitioning on dimension 2.
remark: gemm.cc:27:8: Applying array_partition to 'AB_buff': Complete partitioning on dimension 2.
remark: gemm.cc:34:2: Sequential read of length 64 has been inferred _XLX_SEP_ OldID=load-store-loop11.load.3,  _XLX_SEP_ Aseq A A_port anonymous gemm.cc:34:2 mm(int volatile*, int volatile*, int volatile*) 
remark: gemm.cc:35:2: Sequential read of length 64 has been inferred _XLX_SEP_ OldID=load-store-loop8.load.131,  _XLX_SEP_ Bseq B B_port anonymous gemm.cc:35:2 mm(int volatile*, int volatile*, int volatile*) 
remark: gemm.cc:53:2: Sequential write of length 64 has been inferred _XLX_SEP_ OldID=load-store-loop.store.23,  _XLX_SEP_ ABseq AB AB_port anonymous gemm.cc:53:2 mm(int volatile*, int volatile*, int volatile*) 
remark: gemm.cc:53:2: Could not widen since type i32 size is greater than or equal to the max_widen_bitwidth threshold of 0 _XLX_SEP_ ABseq AB AB_port anonymous gemm.cc:53:2 mm(int volatile*, int volatile*, int volatile*) 
remark: gemm.cc:35:2: Could not widen since type i32 size is greater than or equal to the max_widen_bitwidth threshold of 0 _XLX_SEP_ Bseq B B_port anonymous gemm.cc:35:2 mm(int volatile*, int volatile*, int volatile*) 
remark: gemm.cc:34:2: Could not widen since type i32 size is greater than or equal to the max_widen_bitwidth threshold of 0 _XLX_SEP_ Aseq A A_port anonymous gemm.cc:34:2 mm(int volatile*, int volatile*, int volatile*) 
remark: gemm.cc:34:2: Multiple burst reads of length 64 and bit width 32 has been inferred. These burst requests might be further partitioned into multiple requests during RTL generation, based on max_read_burst_length or max_write_burst_length settings. _XLX_SEP_ seq  A_port anonymous gemm.cc:34:2 mm(int volatile*, int volatile*, int volatile*) 
remark: gemm.cc:34:2: Multiple burst reads of length 64 and bit width 32 in loop 'anonymous'(gemm.cc:34:2) has been inferred on bundle 'A_port'. These burst requests might be further partitioned into multiple requests during RTL generation, based on max_read_burst_length or max_write_burst_length settings.
remark: gemm.cc:35:2: Multiple burst reads of length 64 and bit width 32 has been inferred. These burst requests might be further partitioned into multiple requests during RTL generation, based on max_read_burst_length or max_write_burst_length settings. _XLX_SEP_ seq1  B_port anonymous gemm.cc:35:2 mm(int volatile*, int volatile*, int volatile*) 
remark: gemm.cc:35:2: Multiple burst reads of length 64 and bit width 32 in loop 'anonymous'(gemm.cc:35:2) has been inferred on bundle 'B_port'. These burst requests might be further partitioned into multiple requests during RTL generation, based on max_read_burst_length or max_write_burst_length settings.
remark: gemm.cc:53:2: Multiple burst writes of length 64 and bit width 32 has been inferred. These burst requests might be further partitioned into multiple requests during RTL generation, based on max_read_burst_length or max_write_burst_length settings. _XLX_SEP_ seq2  AB_port anonymous gemm.cc:53:2 mm(int volatile*, int volatile*, int volatile*) 
remark: gemm.cc:53:2: Multiple burst writes of length 64 and bit width 32 in loop 'anonymous'(gemm.cc:53:2) has been inferred on bundle 'AB_port'. These burst requests might be further partitioned into multiple requests during RTL generation, based on max_read_burst_length or max_write_burst_length settings.
